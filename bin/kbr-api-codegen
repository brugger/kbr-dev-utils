#!/usr/bin/env python3


import argparse
import sys
import os
from unittest import case

from kbr import config_utils
from urllib.parse import urlparse

import kbr.args_utils as args_utils
import kbr.version_utils as version_utils
import kbr.dbase.postgres_utils as postgres_utils
from jinja2 import Template

version = version_utils.as_string('kbr')

db = None


api_template = """##### {{tblname}} #####

    def {{tblname}}_create(self{{required_args|join(', ')}}, **values) -> dict:
{% for param in required_params %}
        values['{{param}}'] = {{param}}{% endfor %}

        p = self._db.add('{{tblname}}', values)

        return self._db.get('{{tblname}}', **values)

{% if required_params|length == 1 %}
    def {{tblname}}_create_unique(self{{ required_args|join(', ') }}, **values) -> dict:
{% for param in required_params %}
        values['{{param}}'] = {{param}}{% endfor %}

        return self._db.add_unique('{{tblname}}', values, {{required_params}})

{% endif %}
    def {{tblname}}(self, id:str) -> dict:
        return self._db.get_by_id('{{tblname}}', id)

    def {{tblname}}s(self, **values) -> dict:
        return self._db.get('{{tblname}}', **values)

    def {{tblname}}_update(self, **values) -> dict:
        self._db.update('{{tblname}}', values, {'id': values['id']})

    def {{tblname}}_delete(self, id) -> None:
        self._db.delete('{{tblname}}', id=id)

    def {{tblname}}_purge(self) -> None:
        self._db.purge('{{tblname}}')

"""

cli_template = """

def {{tblname}}_cmd(args) -> None:

    commands = {'c':'create', 's':'show', 'l':'list', 'u':'update', 'd': 'delete', 'p':'purge', 'h':'help'}

    if len(args) == 0:
        args.append('help')

    command = args.pop(0)
    command = args_utils.valid_command(command, commands)

    if command == 'create':
        data = {}
{% for param in required%}
        data[{{param}}] = args_utils.get_or_fail(args, "Missing {{param}}"){% endfor %}
{% for param in optional%}
        data[{{param}}] = args_utils.get_or_default(args, None){% endfor %}

        db.{{tblname}}_create(**data)
#        db.{{tblname}}_create({{params|join(', ')}})

    elif command == 'show':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        entry = db.{{tblname}}(id)
        print( tabulate([entry], headers={}, tablefmt='psql'))

    elif command == 'list':
        {{tblname}}s = db.{{tblname}}s()
        print( tabulate({{tblname}}s, headers={}, tablefmt='psql'))

    elif command == 'update':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        data = args_utils.group_args( args )
        data['id'] = id
        del grouped_args['rest']

        db.{{tblname}}_update(data)

    elif command == 'delete':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        db.{{tblname}}_delete(id)
    elif command == 'purge':
        db.{{tblname}}_purge()

    else:
        print("Help:")
        print("-----------------")
        print("{{tblname}} list")
        print("{{tblname}} create {% for r in required %}[{{r}}] {% endfor %}{% for r in optional %}<{{r}}> {% endfor %}
        print("{{tblname}} show [id]")
        print("{{tblname}} update [id] {% for r in required+optional %}{{r}}:{{r}} {% endfor %}
        print("{{tblname}} delete [id]")
        print("{{tblname}} purge")
        sys.exit()

"""


def to_python_type(dtype:str) -> str:
    if dtype == 'integer':
        return "int"
    elif dtype == 'boolean':
        return "bool"
    elif dtype == 'uuid':
        return "str"
    elif "character" in dtype:
        return "str"
    else:
        return "any"


def module_header() -> str:
    return """
import kbr.db_utils as db

class DB(object):

    def connect(self, url: str) -> None:
        self._db = db.DB(url)

    def disconnect(self) -> None:

        if self._db is not None:
            self._db.close()
"""

def print_api_for_table(tblname:str, tbl:list) -> None:

    required_args = [""]
    required_params = []
    for row in tbl:
        if row['is_nullable'] == 'NO' and row['column_name'] != 'id':
            required_args.append( f"{row['column_name']}:{to_python_type(row['data_type'])}")
            required_params.append( row['column_name'])


    template = Template(api_template)
    print(template.render({'tblname': tblname, 'required_args':required_args, 'required_params': required_params}))



def print_cli_for_table(tblname:str, tbl:list) -> None:

    required = []
    optional  = []
    params = []
    for row in tbl:
        name = row['column_name']
        if name == 'id':
            continue
        params.append(f"{name}={name}")
        if row['is_nullable'] == 'NO':
            required.append( name)
        else:
            optional.append( name)

    template = Template(cli_template)
    print(template.render({'tblname': tblname, 'required': required, 'optional': optional, 'params':params}))


def print_facade(project:str) -> None:
    print(f"""
import {project}.db as db

class DB(db.DB):

    def new_function() -> None:
        print("Add fancy facade stuff here...")
        return
""")


def read_config(config_file) -> dict:
    try:

        config = config_utils.readin_config_file(config_file)
        return config
    except Exception as e :
#        print (e)
        print("Error:")
        print(f"{config_file}, does not exit\n")        
        print("Howto create:\nsudo -u postgres psql")
        print("CREATE USER <ADMIN> WITH SUPERUSER PASSWORD '<PASSWORD>';")
        print('{"admin_dbase": "postgresql://<ADMIN>:<PASSWORD>@localhost/"}')
        sys.exit()


def main():
    parser = argparse.ArgumentParser(description="kbr dev utils (version: {version})".format(version=version))
    commands = {'a': 'api', 'f': 'facade', 'c': 'cli', 'h':'help'}
    parser.add_argument('-c', '--config-file', default=[os.getenv("HOME") + "/.kbr_dev_utils.json"], help="output facade of api-file", nargs=1)
    parser.add_argument('-A', '--all-tables', default=False, help="all tables in database", action="store_true")
    parser.add_argument('command', nargs='+', help="List of tables to make api code for")

    args = parser.parse_args()

    config = read_config(args.config_file[0])

    command = args.command.pop(0)
    if command in commands:
        command = commands[ command ]


    if command == 'facade':
        pname = args_utils.get_or_fail(args.command, "project name is missing")
        print_facade( pname )
    elif command in ['api', 'cli']:
        dbname = args_utils.get_or_fail(args.command, "Missing database name")
        if command == 'api' and 'header' in args.command:
            args.command.pop(args.command.index('header'))
            print(module_header())

        db = postgres_utils.DB(config['admin_dbase']+dbname)

        if args.all_tables:
            args.command +=  [ v['tablename'] for v in db.tables_list()]


        while len(args.command):

            tblname = args_utils.get_or_default(args.command, "Missing table name")
#            print(tbname)
            tbl = db.table_details(tblname)
            if command == 'api':
                print_api_for_table(tblname, tbl)
            elif command == 'cli':
                print_cli_for_table(tblname, tbl)



if __name__ == "__main__":
    main()
