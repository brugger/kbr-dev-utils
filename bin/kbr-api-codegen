#!/usr/bin/env python3


import argparse
import sys
import os
from unittest import case

from kbr import config_utils
from urllib.parse import urlparse

import kbr.args_utils as args_utils
import kbr.version_utils as version_utils
import kbr.dbase.postgres_utils as postgres_utils
from jinja2 import Template

version = version_utils.as_string('kbr')

db = None


api_template = """##### {{tblname}} #####

    def {{tblname}}_create(self{{required_args|join(', ')}}, **values) -> dict:
{% for param in required_params %}
        values['{{param}}'] = {{param}}{% endfor %}

        p = self._db.add('{{tblname}}', values)

        return self._db.get('{{tblname}}', **values)

{% if required_params|length == 1 %}
    def {{tblname}}_create_unique(self{{ required_args|join(', ') }}, **values) -> dict:
{% for param in required_params %}
        values['{{param}}'] = {{param}}{% endfor %}

        return self._db.add_unique('{{tblname}}', values, {{required_params}})

{% endif %}
    def {{tblname}}(self, id:str) -> dict:
        return self._db.get_by_id('{{tblname}}', id)

    def {{tblname}}s(self, **values) -> dict:
        return self._db.get('{{tblname}}', **values)

    def {{tblname}}_update(self, **values) -> dict:
        self._db.update('{{tblname}}', values, {'id': values['id']})

    def {{tblname}}_delete(self, id) -> None:
        self._db.delete('{{tblname}}', id=id)

    def {{tblname}}_purge(self) -> None:
        self._db.purge('{{tblname}}')

"""

cli_template = """

def {{tblname}}_cmd(args) -> None:

    commands = {'c':'create', 's':'show', 'l':'list', 'u':'update', 'd': 'delete', 'p':'purge', 'h':'help'}

    if len(args) == 0:
        args.append('help')

    command = args.pop(0)
    command = args_utils.valid_command(command, commands)

    if command == 'create':
        data = {}
{% for param in required%}
        data[{{param}}] = args_utils.get_or_fail(args, "Missing {{param}}"){% endfor %}
{% for param in optional%}
        data[{{param}}] = args_utils.get_or_default(args, None){% endfor %}

        db.{{tblname}}_create(**data)
#        db.{{tblname}}_create({{params|join(', ')}})

    elif command == 'show':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        entry = db.{{tblname}}(id)
        print( tabulate(entry, headers={}, tablefmt='psql'))

    elif command == 'list':
        {{tblname}}s = db.{{tblname}}s()
        print( tabulate({{tblname}}s, headers={}, tablefmt='psql'))

    elif command == 'update':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        data = args_utils.group_args( args )
        data['id'] = id
        del data['rest']

        db.{{tblname}}_update(**data)

    elif command == 'delete':
        id = args_utils.get_or_fail(args, "Missing {{tblname}} id")
        db.{{tblname}}_delete(id)
    elif command == 'purge':
        db.{{tblname}}_purge()

    else:
        print("Help:")
        print("-----------------")
        print("{{tblname}} list")
        print("{{tblname}} create {% for r in required %}[{{r}}] {% endfor %}{% for r in optional %}<{{r}}> {% endfor %}
        print("{{tblname}} show [id]")
        print("{{tblname}} update [id] {% for r in required+optional %}{{r}}:{{r}} {% endfor %}
        print("{{tblname}} delete [id]")
        print("{{tblname}} purge")
        sys.exit()

"""

rest_template = """

class {{tblname}}DetailHandler ( tornado.BaseHandler ):

    def endpoint(self):
        return("/{{tblname}}/[id]")

    def get(self, id:str):
        {{tblname}}  = db.{{tblname}}_get(id=id)
        if {{tblname}} is None:
            self.send_response_404()

        return self.send_response( data={{tblname}})

    def patch(self, id:str):
        {{tblname}} = db.{{tblname}}_get(id=id)
        if {{tblname}} is None:
            self.send_response_404()

        values = self.post_values()
        # Check and change here!
        self.valid_arguments(data, [{{table_fields|join(", ")}}])

        db.{{tblname}}_update(id=id, data)
        return self.send_response_204( )

    def delete(self, id:str):
        try:
            db.{{tblname}}_delete( id=id )
            return self.send_response_204()
        except:
            return self.send_response_400()

class {{tblname}}sListHandler( tornado.BaseHandler):
    def endpoint(self):
        return "/{{tblname}}s/"

    def post(self):
        values = self.post_values()
        # check and change here
        self.require_arguments(values, [{{table_required_fields|join(', ')}}])
        self.valid_arguments(values, [{{table_fields|join(', ')}}])
        try:
            db.{{tblname}}_create(values)
            self.send_response_200()
        except Exception as e:
            logger.error(f"Request export tracking error {e}")
            self.send_response_404()

    def get(self):
        filter = self.arguments()
        # check and change here
        self.valid_arguments(filter, [{{table_fields|join(', ')}}])
        return self.send_response( db.{{tblname}}s( **filter ))

class {{tblname}}DoHandler (tornado.BaseHandler):

    def endpoint(self):
        return("/{{tblname}}/do/")

    def post(self, id:str, ):
        values = self.post_values()
        self.require_arguments(values, ['action'])
        self.valid_arguments(values, [{{table_fields|join(', ')}}])

        return self.send_response_501()

"""

rest_file_template = """
#!/usr/bin/env python

''' REST API for {{project}}'''

import argparse

import kbr.log_utils as logger
import kbr.config_utils as config_utils
import kbr.version_utils as version_utils

#import kbr_api.auth     as oauth
import kbr_api.tornado   as tornado

import {{project}}.db as {{project}}_db


db = None
version = version_utils.as_string()

class RootHandler ( tornado.BaseHandler ):

    def endpoint(self):
        return("/")

    def get(self):
        return self.send_response(data={"name":"{{project}}-api", "version":version})


{{handlers}}

def main():
    parser = argparse.ArgumentParser(description='{{project}}-api: the rest service for {{project}}')


    parser.add_argument('-c', '--config', default="api.json", help="config file, can be overridden by parameters")

    parser.add_argument('-l', '--logfile', default=None, help="Logfile to write to, default is stdout")
    parser.add_argument('-p', '--port', help="Port to bind to")
    parser.add_argument('-v', '--verbose', default=4, action="count",  help="Increase the verbosity of logging output")

    args = parser.parse_args()

    config = config_utils.readin_config_file( args.config )

    if args.port:
        config.server.port = args.port

    if args.logfile:
        config.logfile = args.logfile

    logger.init(name=config.name, log_file=config.logfile )
    logger.set_log_level( args.verbose )

    if 'database' in config:
        global db
        db = {{project}}_db.DB()
        db.connect( config.database )

    urls = [('/', RootHandler),
{% for table in tables %}    
            (r'/{{table}}s/do/?$',     {{table|capitalize}}sDoHandler),
            (r'/{{table}}s/(\d+)/?$',  {{table|capitalize}}DetailHandler),
            (r'/{{table}}/?$',         {{table|capitalize}}sListHandler),{%endfor%}

            ]# + oauth.init( **config.oauth )

    tornado.run_app( urls, **config.server )

if __name__ == "__main__":
    main()
"""



def to_python_type(dtype:str) -> str:
    if dtype == 'integer':
        return "int"
    elif dtype == 'boolean':
        return "bool"
    elif dtype == 'uuid':
        return "str"
    elif "character" in dtype:
        return "str"
    else:
        return "any"


def module_header() -> str:
    return """
import kbr.db_utils as db

class DB(object):

    def connect(self, url: str) -> None:
        self._db = db.DB(url)

    def disconnect(self) -> None:

        if self._db is not None:
            self._db.close()
"""

def cli_header(tables:list) -> None:

    header_template = """
def table_cmd(args) -> None:
    commands = { {%for t in tables%}'{{t[0]}}':'{{t}}'{% endfor %} 'h':'help'}

    if len(args.command) == 0:
        args.command.append('help')

    command = args.command.pop(0)
    command = args_utils.valid_command(command, commands)
    {% set ns = namespace(else_if='') %}
    {% for table in tables%}
    {{ns.else_if}}if command == '{{table}}':
        {{table}}_cmd(args.command)
        {% set ns.else_if = 'el' %}{%endfor%}
    else:
        print("table: {}".format(args_utils.pretty_commands(commands)))
        sys.exit()
"""

    template = Template(header_template)
    print(template.render({'tables': tables}))


def rest_header(tables:list) -> None:

    template = Template(rest_file_template)
    print(template.render({'tables': tables}))

def print_api_for_table(tblname:str, tbl:list) -> None:

    required_args = [""]
    required_params = []
    for row in tbl:
        if row['is_nullable'] == 'NO' and row['column_name'] != 'id':
            required_args.append( f"{row['column_name']}:{to_python_type(row['data_type'])}")
            required_params.append( row['column_name'])


    template = Template(api_template)
    print(template.render({'tblname': tblname, 'required_args':required_args, 'required_params': required_params}))



def print_rest_for_table(tblname:str, tbl:list) -> None:

    fields_required = []
    fields = []
    for row in tbl:
        if row['is_nullable'] == 'NO' and row['column_name'] != 'id':
            fields_required.append(f"'{row['column_name']}'")
        
        fields.append(f"'{row['column_name']}'")

    template = Template(rest_template)
    print(template.render({'tblname': tblname, 'table_fields':fields, 'table_required_fields': fields_required}))


def print_cli_for_table(tblname:str, tbl:list) -> None:

    required = []
    optional  = []
    params = []
    for row in tbl:
        name = row['column_name']
        if name == 'id':
            continue
        params.append(f"{name}={name}")
        if row['is_nullable'] == 'NO':
            required.append( name)
        else:
            optional.append( name)

    template = Template(cli_template)
    print(template.render({'tblname': tblname, 'required': required, 'optional': optional, 'params':params}))


def print_facade(project:str) -> None:
    print(f"""
import {project}.db as db

class DB(db.DB):

    def new_function() -> None:
        print("Add fancy facade stuff here...")
        return
""")


def read_config(config_file) -> dict:
    try:

        config = config_utils.readin_config_file(config_file)
        return config
    except Exception as e :
#        print (e)
        print("Error:")
        print(f"{config_file}, does not exit\n")        
        print("Howto create:\nsudo -u postgres psql")
        print("CREATE USER <ADMIN> WITH SUPERUSER PASSWORD '<PASSWORD>';")
        print('{"admin_dbase": "postgresql://<ADMIN>:<PASSWORD>@localhost/"}')
        sys.exit()


def main():
    parser = argparse.ArgumentParser(description="kbr dev utils (version: {version})".format(version=version))
    commands = {'a': 'api', 'f': 'facade', 'c': 'cli', 'r':'rest', 'h':'help'}
    parser.add_argument('-c', '--config-file', default=[os.getenv("HOME") + "/.kbr_dev_utils.json"], help="output facade of api-file", nargs=1)
    parser.add_argument('-A', '--all-tables', default=False, help="all tables in database", action="store_true")
    parser.add_argument('command', nargs='+', help="List of tables to make api code for")

    args = parser.parse_args()

    config = read_config(args.config_file[0])

    command = args.command.pop(0)
    if command in commands:
        command = commands[ command ]


    if command == 'facade':
        pname = args_utils.get_or_fail(args.command, "project name is missing")
        print_facade( pname )
    elif command in ['api', 'cli', 'rest']:
        dbname = args_utils.get_or_fail(args.command, "Missing database name")
        if command == 'api' and 'header' in args.command:
            args.command.pop(args.command.index('header'))
            print(module_header())

        db = postgres_utils.DB(config['admin_dbase']+dbname)

        if command == 'cli' and 'header' in args.command:
            args.command.pop(args.command.index('header'))
            cli_header([ v['tablename'] for v in db.tables_list()])


        if command == 'rest' and 'header' in args.command:
            args.command.pop(args.command.index('header'))
            rest_header([ v['tablename'] for v in db.tables_list()])
            sys.exit()

        if args.all_tables:
            args.command +=  [ v['tablename'] for v in db.tables_list()]


        while len(args.command):

            tblname = args_utils.get_or_default(args.command, "Missing table name")
#            print(tbname)
            tbl = db.table_details(tblname)
            if command == 'api':
                print_api_for_table(tblname, tbl)
            elif command == 'cli':
                print_cli_for_table(tblname, tbl)
            elif command == 'rest':
                print_rest_for_table(tblname, tbl)



if __name__ == "__main__":
    main()
